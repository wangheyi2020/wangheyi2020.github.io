{"posts":[{"title":"动态开点","content":"引入 如果将线段树区间修改、区间查询的值域变成 10910^9109，并强制在线，很明显，简单的线段树在空间上并不能通过，由于强制在线又不能将询问离散化，这就需要动态开点来解决这个空间上的问题。 简介 顾名思义，动态开点就是动态地分配内存，由于对 [1,n][1,n][1,n] 建线段树需要 O(n)O(n)O(n) 的空间，但实际上操作次数远比值域小，但是对于一个修改，只对根到叶子的那条链上的信息有贡献，如果中途遇到哪个点没有被之前的操作涉及到，就开点，因此空间复杂度是 O(mlog⁡n)O(m \\log n)O(mlogn) 的，这时显然不能将 iii 的儿子简单的编号为 i×2i\\times 2i×2 和 i×2+1i\\times 2+1i×2+1，因此需要对每个点额外记录左右儿子。 查询需要注意计算没有开的点对答案的贡献。 很明显，这种动态开点线段树支持区间修改。 给出区间修改，区间查询的代码：线段树1 应用 解决值域较大的问题，在需要的时候在开空间 可持久化数据结构（如可持久化 Trie，可持久化线段树） 对于第一种应用，直接动态地点亮这棵权值线段树即可； 以线段树为例，第二种应用需要先建树，后面的每一次修改操作就可以把相关的那条链复制一遍后再修改，也就是新建了一个根，以它为根的那棵线段树就是第 iii 次修改过后的线段树，再把所有不受影响的儿子和受影响的父亲连上，那么对于 [l,r][l,r][l,r] 的线段树就是第 rrr 个和第 l−1l-1l−1 个根的线段树差分一下（注意：维护同一个值域的线段树形态一定是一样的），下文将不会再提及这种应用。 实现 修改 void add(int &amp;u,int st,int ed,int l,int r,int k) // &amp; 是为了给传进来的点编号 { if(!u) u=++tot; // 如果没有开这个点就开点 if(l&lt;=st&amp;&amp;r&gt;=ed) { t[u].v+=(ed-st+1)*k; tag[u]+=k; return ; } if(r&lt;st||l&gt;ed) return ; int mid=(st+ed)&gt;&gt;1; push_down(u,st,ed); add(t[u].ls,st,mid,l,r,k); add(t[u].rs,mid+1,ed,l,r,k); t[u].v=t[t[u].ls].v+t[t[u].rs].v; } 查询 和普通线段树的区间查询差不多，注意未开的点此时不做贡献 int sum(int u,int st,int ed,int l,int r) { if(!u) return 0; // 未开的点此时不做贡献 if(ed&lt;l||r&lt;st) return 0; if(l&lt;=st&amp;&amp;ed&lt;=r) return t[u].v; int mid=(st+ed)&gt;&gt;1; push_down(u,st,ed); return sum(t[u].ls,st,mid,l,r)+sum(t[u].rs,mid+1,ed,l,r); } 例题1： 取余最长路 给定一个 333 行 nnn 列的带权矩阵和 ppp，从 (1,1)(1,1)(1,1) 开始，每次可以向右或向下走，求一条走到 (3,n)(3,n)(3,n) 的路径，使得路径上的权值和在模 ppp 意义下的最大值。 思路： 可以发现需要恰好向下走两次，记第一、二、三行的前缀和分别是 aka_kak​，bkb_kbk​，ckc_kck​，在第 iii，jjj 两列向下走，那么权值和是 ai+bj−bi−1+cn−cj−1a_i+b_j-b_{i-1}+c_n-c_{j-1}ai​+bj​−bi−1​+cn​−cj−1​。 显然可以枚举 iii，jjj 之一，为了防止出现删除操作，姑且枚举 jjj，并记 kkk 为 bj+cn−cj−1b_j+c_n-c_{j-1}bj​+cn​−cj−1​ 模 ppp 意义下的值，did_idi​ 为 ai−bi−1a_i-b_{i-1}ai​−bi−1​ 模 ppp 意义下的值。 那么对于每一个 jjj，有两种情况使得 di+kd_i+kdi​+k 在模意义下最大： di+k≥pd_i+k \\ge pdi​+k≥p 时，为最大的 did_idi​； di+k&lt;pd_i+k&lt;pdi​+k&lt;p 时，为满足 di&lt;p−kd_i &lt; p-kdi​&lt;p−k 的最大值。 两种情况的求法分别是： 即 [1,j][1,j][1,j] 的前缀最大值； 经典二维偏序问题，但由于值域过大，直接动态开点一棵值域线段树，相当于是个单点修改和区间最值。 取 max⁡\\maxmax 打擂台即可。 代码： #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; int n,p,a[(int)(1e5+10)],b[(int)(1e5+10)],c[(int)(1e5+10)]; int pre[(int)(1e5+10)],tot; struct node { int v,ls,rs; }t[(int)(4e6+10)]; void add(int &amp;u,int st,int ed,int x,int k) { if(!u) u=++tot; if(st==ed){t[u].v=k;return ;} int mid=(st+ed)&gt;&gt;1; if(mid&gt;=x) add(t[u].ls,st,mid,x,k); else add(t[u].rs,mid+1,ed,x,k); t[u].v=max(t[t[u].ls].v,t[t[u].rs].v); } int query(int u,int st,int ed,int l,int r) { if(!u) return 0; if(ed&lt;l||r&lt;st) return 0; if(l&lt;=st&amp;&amp;ed&lt;=r) return t[u].v; int mid=(st+ed)&gt;&gt;1; return max(query(t[u].ls,st,mid,l,r),query(t[u].rs,mid+1,ed,l,r)); } signed main() { cin&gt;&gt;n&gt;&gt;p;int k,mx=-1,root=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;k,a[i]=a[i-1]+k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;k,b[i]=b[i-1]+k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;k,c[i]=c[i-1]+k; for(int i=1;i&lt;=n;i++) pre[i]=a[i]-b[i-1]; for(int i=1;i&lt;=n;i++) { while(pre[i]&lt;0) pre[i]+=p; pre[i]%=p; } int ans=0; for(int i=1;i&lt;=n;i++) { add(root,1,1e9,pre[i],pre[i]); k=b[i]+c[n]-c[i-1];k%=p; ans=max(ans,(k+query(root,1,1e9,1,p-k-1))%p); mx=max(pre[i],mx);ans=max(ans,(k+mx)%p); } cout&lt;&lt;ans; system(&quot;pause &gt; null&quot;); } 例题2 CF803G 2300* 有一个序列 aaa，对于 QQQ 次查询，每次查询有两种操作： 将 [l,r][l,r][l,r] 的所有数区间赋值为 xxx 求 [l,r][l,r][l,r] 的区间最小值 序列 aaa 是由一个长度为 nnn 的序列 bbb 自我复制 kkk 次得到的 1≤n,q≤1051\\leq n,q\\leq 10^51≤n,q≤105，1≤k≤1041\\leq k\\leq 10^41≤k≤104，1≤bi≤1091\\leq b_i\\leq 10^91≤bi​≤109 1≤l≤r≤n×k1\\leq l\\leq r\\leq n\\times k1≤l≤r≤n×k 思路 tit_iti​ 维护某段区间的最小值 首先考虑 bbb 序列是 nnn 个极大值的时候，那么这时一切区间如果被覆盖过了，原数都不会做贡献，由于值域很大，动态开点即可。 仔细观察性质，可以发现： 对于修改，aaa 序列一定不会被涉及到，因为开出来的点的 tit_iti​ 都是覆盖的值，直接覆盖即可 对于查询，考虑到询问区间只会由两种类型的子区间做贡献，要么是已经开的点，要么是还没有开的点，如果已经开点，直接返回 tit_iti​ 即可；对于没有开的点，显然并不是不做贡献，贡献就是 [l,r][l,r][l,r] 这段区间的最小值即可，由于这个点没有开，所以这个区间是原序列的子段，分讨三种贡献的情况： 贡献是 bbb 序列的最小值，等价于 r−l+1≥nr-l+1\\geq nr−l+1≥n 贡献是 bbb 序列的一段区间最小值，等价于 [l,r][l,r][l,r] 被某个循环节包含 贡献是 bbb 序列的某段后缀最小值和某段前缀最小值取小，其他情况 直接将区间映射到原序列，st 表即可维护询问时没开点的值，维护完了记得开点。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int n,q,tot,m,a[(int)(3e5+10)],tag[(int)(1e7+10)],st[(int)(3e5+10)][30]; int get(int x,int y) // st 表求区间最小值 { int k=log2(y-x+1); return min(st[x][k],st[y-(1&lt;&lt;k)+1][k]); } int to(int a) // 映射到 b 序列 { if(a%n==0) return n; return a%n; } int ask(int l,int r) // 分讨三种贡献情况 { if(r-l+1&gt;=n) return get(1,n); int bl1=ceil((long double)l/(long double)n),bl2=ceil((long double)r/(long double)n); if(bl1==bl2) { return get(to(l),to(r)); } return min(get(to(l),n),get(1,to(r))); } struct node { int v,ls,rs; }t[(int)(2e7+10)]; void upd(int u,int st,int ed,int k) { t[u].v=k; tag[u]=k; } void push_down(int u,int st,int ed) { if(tag[u]==0) return ; if(!t[u].ls) t[u].ls=++tot; if(!t[u].rs) t[u].rs=++tot; int mid=(st+ed)&gt;&gt;1; upd(t[u].ls,st,mid,tag[u]); upd(t[u].rs,mid+1,ed,tag[u]); tag[u]=0; } void add(int &amp;u,int st,int ed,int l,int r,int k) { if(!u) u=++tot,t[u].v=ask(st,ed); // 开点，并维护未开的点值 if(l&lt;=st&amp;&amp;r&gt;=ed) { t[u].v=k; tag[u]=k; return ; } if(r&lt;st||l&gt;ed) return ; push_down(u,st,ed); int mid=(st+ed)&gt;&gt;1; add(t[u].ls,st,mid,l,r,k); add(t[u].rs,mid+1,ed,l,r,k); t[u].v=min(t[t[u].ls].v,t[t[u].rs].v); } int sum(int &amp;u,int st,int ed,int l,int r) { if(!u) u=++tot,t[u].v=ask(st,ed); // 开点，并维护未开的点值 if(ed&lt;l||r&lt;st) return INT_MAX; if(l&lt;=st&amp;&amp;ed&lt;=r) return t[u].v; push_down(u,st,ed); int mid=(st+ed)&gt;&gt;1; return min(sum(t[u].ls,st,mid,l,r),sum(t[u].rs,mid+1,ed,l,r)); } signed main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],st[i][0]=a[i]; for(int j=1;j&lt;=20;j++) // st 表预处理 { for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) { st[i][j]=min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]); } } int root=0,num=0; cin&gt;&gt;q; while(q--) { int op;cin&gt;&gt;op; if(op==1) { int l,r,k;cin&gt;&gt;l&gt;&gt;r&gt;&gt;k; add(root,1,1e9,l,r,k); } else { int l,r;cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;sum(root,1,1e9,l,r)&lt;&lt;&quot;\\n&quot;; } } } ","link":"https://wangheyi2020.github.io/post/dong-tai-kai-dian/"},{"title":"[Solution] 好题题解","content":" 建议倒序阅读 CF1423K 题意： 多组询问，每次询问给出 nnn ，回答对于所以 i∈[1,n]i\\in [1,n]i∈[1,n] ，有多少个 iii 满足不存在 j∈[1,n]j\\in [1,n]j∈[1,n] 使得 gcd⁡(i,j)\\gcd(i,j)gcd(i,j) ，jgcd⁡(i,j)\\frac{j}{\\gcd(i,j)}gcd(i,j)j​ ，igcd⁡(i,j)\\frac{i}{\\gcd(i,j)}gcd(i,j)i​ 构成三角形 。 思路： 首先观察样例可以发现： 偶数一定不对答案有贡献，因为可以选择 iii 和 i±2i\\pm2i±2 使得他们的最大公约数为 222 ，另外两边之差一定是 111 ； 可以依照这种思路分类下去，由于奇数的情况有些复杂在最后讨论； 考虑某些质数 ppp ，那么 gcd⁡(p,j)\\gcd(p,j)gcd(p,j) 一定是 111 或 ppp ，pgcd⁡(p,j)\\frac{p}{\\gcd(p,j)}gcd(p,j)p​ 与对应上面是 ppp 或 111 ，jgcd⁡(p,j)\\frac{j}{\\gcd(p,j)}gcd(p,j)j​ 与上面对应一定是 jjj 或 jp\\frac{j}{p}pj​ ，发现不管怎么样都存在恰好 111 个 111 ，所以两个不等于 111 的值必须相等，那么 j←p2j\\gets p^2j←p2 即可，那么显然 p≤np\\leq \\sqrt np≤n​ 的质数都存在 jjj 满足条件； 现在考虑奇数的情况，质数已经证明可以，合数可以选择其最小的质因子 ppp ，可以构造 i−pi-pi−p ，iii 即可； 综上，所有合数满足条件，大于 n\\sqrt nn​ 的质数都不满足，111 不满足，求前缀素数个数 sis_isi​ 表示 1−i1-i1−i 的素数个数，答案即为 sn−sn+1s_n-s_{\\sqrt n}+1sn​−sn​​+1 CF1554D 题意： 构造一个字符串使得其每个子串都出现奇数次 思路： 考虑摆一堆相同的字符上去，可以发现 如果长度为偶数，那么他长度为奇数的子串有偶数个，长度为偶数的子串有奇数个 反之如果长度为奇数，那么长度为奇数的子串奇数个，长度为偶数的子串偶数个 那么我们可以想到把让相同的子串拼起来，使得偶数变成奇数，那么我们需要一个长度为 lll 的字符串和一个长度为 l−1l-1l−1 的字符串达到目标，但是我们需要保证这两个串是相互独立的，只需要在中间添加无关的字符 简而言之，就是在前面摆 n2\\frac{n}{2}2n​ 个某一种字符，在最后摆 n2−1\\frac{n}{2}-12n​−1 个相同种类的字符 ，中间缺失的部分至多只有 222 个，放上无关字符即可，容易证明无关字符不对答案产生影响 CF1179B 题意： 你站在一个 n×mn\\times mn×m 的网格的 (1,1)(1,1)(1,1) ，每次可以选择一个数对 (dx,dy)(dx,dy)(dx,dy) ，把你的位置 (x,y)(x,y)(x,y) 变为 (x+dx,y+dy)(x+dx,y+dy)(x+dx,y+dy) ，使得你经过了每一个格点，并且没有重复使用同一个数对，请构造出路径。 思路： 神仙构造题，观察第一个样例，发现可以对于每一行都形如 (1,y)−(n,y)−(2,y)−(n−1,y)(1,y)-(n,y)-(2,y)-(n-1,y)(1,y)−(n,y)−(2,y)−(n−1,y) 这么走下来，考虑纵向怎么走。默认你在 (a,b)(a,b)(a,b) 这个位置 ，大力构造，每次把未被处理的最下面一行和未被处理的最上面一行进行操作，即前两次的处理是 (1,1)−(n,m)−(2,1)−(n−1,m)−...−(1,n)−(n,1)(1,1)-(n,m)-(2,1)-(n-1,m)-...-(1,n)-(n,1)(1,1)−(n,m)−(2,1)−(n−1,m)−...−(1,n)−(n,1) ，然后每次找该处理那两行即可。 注意分讨奇偶 CF761E 思路： 无解显然等价于存在点度大于 444 的节点，因为与 (x,y)(x,y)(x,y) 关于坐标轴平行的点满足边不相交只有 444 个 钦定 111 为根 第一反应是边权要尽量大，要不然容易出现兄弟节点重合的情况，但由于边不能相交，所以边权要随着树的层数的增加不断减小，假设深度为 ddd，iii 和它子节点的连边的权值是 pip_ipi​，那么应该满足对于任意 iii，都有 pi&gt;∑i&lt;k≤dpkp_i &gt; \\sum_{i&lt; k \\leq d} p_kpi​&gt;∑i&lt;k≤d​pk​，满足这个等式的构造方法是显然的，即对于任意 1≤i≤d1\\leq i\\leq d1≤i≤d，满足pi=2n−i+1p_i=2^{n-i+1}pi​=2n−i+1，因为 nnn 很小，所以不必担心跑出 101810^{18}1018。 现在每条边的权值已经得到，还需要考虑 uuu 的子节点的方向不能朝向 uuu 的父节点，记录来的方向即可。 CF182C 思路： 由于区间长度给定，所以考虑枚举那个区间是答案，显然只有 nnn 种情况，由于对于 [l,r][l,r][l,r] 这个长度合法的区间，要么改所有负数中前 kkk 小，要么改所有正数中前 kkk 大，显然把序列全部取相反数就能把第二个问题变成第一个问题，因此以下所有讨论都是对于改负数中 kkk 小的。 区间第 kkk 小值应该都能用各种方法求出，由于这个区间具有长度给定且左端点一直向右的特性，可以选择用码量特别小的 vectorvectorvector 实现二分插入到哪然后快速插入保持单调性，当区间移到 [l,r][l,r][l,r] 时，判断如果 ara_rar​ 是负数就插入，如果 al−1a_{l-1}al−1​ 被插入了就删掉 al−1a_{l-1}al−1​，然后如果存在第 kkk 大就记录，否则记录其中的最大值，由于具有单调性，直接访问即可，使用 pip_ipi​ 记录其值和所在区间。 然后问题就转化为，对每一个 iii，求 [i,i+len−1][i,i+len-1][i,i+len−1] 这个下标区间内比 pip_ipi​ 小的数之和加上一部分 pip_ipi​ 然后打擂台比一下，这个也正是这题最具有思维难度的部分（但事实证明只有我这种阴间方法需要处理这个问题），直接考虑离线，按 pip_ipi​ 的值为第一关键字排序，那么所有合法的值必然在 pip_ipi​ 加入树状数组之前已经加入了，具体而言，就是把所有比 pip_ipi​ 小还而且还没有加入树状数组的 aia_iai​ 加进去，显然每次大力找是 n2n^2n2 级别的，但是实际上只需要加入 nnn 次，所以顺手把 aia_iai​ 也排序，记录下标，然后双指针即可，需要有多少个 pip_ipi​ 可以各种方法算，比如再开一个树状数组维护个数。 CF1628D1 思路： 发现 kkk 是最没有用的变量，因为等价于在 [0,1][0,1][0,1] 中选一个实数的答案扩大 kkk 倍，因为策略总是相同的。 先手玩 n=1n=1n=1 的答案，发现当 m=0m=0m=0 时 Alice 一定会选 000，m=1m=1m=1 时 Alice 会蹬鼻子上脸选 111，因为他怎么选 Bob 都得加上去。 设 fi,jf_{i,j}fi,j​ 表示 n=i,m=jn=i,m=jn=i,m=j 时的答案，那么 fi,0=0f_{i,0}=0fi,0​=0，fi,i=if_{i,i}=ifi,i​=i。 手玩 n=2,m=1n=2,m=1n=2,m=1 时发现不是那么显然，假设 Alice 给出了 ppp 这个实数，那么 Bob 可以选择加或不加，也就是 f2,1=min⁡(f1,0+p,f1,1−p)f_{2,1}=\\min(f_{1,0}+p,f_{1,1}-p)f2,1​=min(f1,0​+p,f1,1​−p)，当然 Alice 是足够聪明的，自然会让 min⁡(f1,0+p,f1,1−p)\\min(f_{1,0}+p,f_{1,1}-p)min(f1,0​+p,f1,1​−p) 尽量大，也就是使得 f1,0+p=f1,1−pf_{1,0}+p=f_{1,1}-pf1,0​+p=f1,1​−p，即取 p=f1,1−f1,02p=\\frac{f_{1,1}-f_{1,0}}{2}p=2f1,1​−f1,0​​，带入 ppp 得到 f2,1=f1,1+f1,02f_{2,1}=\\frac{f_{1,1}+f_{1,0}}{2}f2,1​=2f1,1​+f1,0​​。 因此得到一般情况下 fi,j=fi−1,j−1+fi−1,j2f_{i,j}=\\frac{f_{i-1,j-1}+f_{i-1,j}}{2}fi,j​=2fi−1,j−1​+fi−1,j​​。 考虑到最后是在模 109+710^9+7109+7 意义下的分数，直接求 222 的逆元乘起来即可，当然也可以模拟分数。 CF173E 独立想+写出来了，纪念一下。 思路： 注意到，如果 iii 成为了队长，他的队伍里必然包含了所有 r≤rir\\leq r_ir≤ri​ 且年龄差小于 kkk 的人，因为队员之间是没有限制的。 首先发现，对于一组 xxx，yyy 的询问，对于任意 iii 满足 ri≥max⁡(rx,ry)r_i\\geq\\max(r_x,r_y)ri​≥max(rx​,ry​) 且 aia_iai​ 在 [ax−k,ax+k][a_x-k,a_x+k][ax​−k,ax​+k] 交 [ay−k,ay+k][a_y-k,a_y+k][ay​−k,ay​+k] ，iii 就可能成为队长，很显然，iii 作为队长的队伍中必然包含了 xxx 和 yyy。 可以考虑求得任意 iii 作为队长时队伍中的人数，转化为一个经典的二维偏序问题，按 rrr 排序后，动态开点值域线段树维护即可，记为 pip_ipi​。 随后问题转化就为了，就是给定了 nnn 个三元组，形如 (r,a,p)(r,a,p)(r,a,p)，求所有满足 r≥kr\\geq kr≥k 且 aaa 属于 [l,r][l,r][l,r] 的三元组的 ppp 的最大值，其中的 kkk，lll，rrr 都是与询问的 xxx，yyy 有关的，不多赘述。 这个问题显然可以按 kkk 排序，由于三元组已经按 rrr 排序，那么就消除了第一个限制，考虑在 aaa 处插入一个 ppp 然后取 max⁡\\maxmax，动态开点值域线段树维护即可。 ","link":"https://wangheyi2020.github.io/post/20/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://wangheyi2020.github.io/post/hello-gridea/"}]}